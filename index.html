<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>英単語学習アプリ (複数意味対応版) — 改良v1.2</title>
    <style>
        :root { --main-color: #007bff; --light-gray: #f8f9fa; --gray: #6c757d; --red: #dc3545; --green: #28a745; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; background-color: var(--light-gray); display: flex; justify-content: center; }
        .container { width: 100%; max-width: 1000px; background-color: #fff; margin: 20px; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1, h2 { color: #333; text-align: center; }
        .controls, .quiz-controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 20px; align-items: center; }
        .controls input[type="text"], .controls input[type="number"], .controls select { padding: 8px; border: 1px solid #ccc; border-radius: 4px; min-width: 120px; }
        button { padding: 10px 15px; border: none; border-radius: 4px; color: #fff; cursor: pointer; transition: background-color 0.2s; }
        .btn-primary { background-color: var(--main-color); }
        .btn-primary:hover { background-color: #0056b3; }
        .btn-secondary { background-color: var(--gray); }
        .btn-secondary:hover { background-color: #5a6268; }
        .btn-success { background-color: var(--green); }
        .btn-success:hover { background-color: #218838; }
        #word-list { list-style: none; padding: 0; max-height: 400px; overflow-y: auto; border-top: 1px solid #eee; margin-top: 10px; }
        .word-item { display: flex; align-items: flex-start; gap: 10px; padding: 10px; border-bottom: 1px solid #eee; }
        .word-item.hidden { opacity: 0.4; }
        .word-item.checked { background-color: #e9f5ff; }
        .word-item input[type="checkbox"] { margin-top: 5px; width: 18px; height: 18px; flex-shrink: 0; }
        .word-details { flex-grow: 1; }
        .word-details .word { font-size: 1.2em; font-weight: bold; }
        .definition-item { margin-top: 8px; margin-left: 10px; }
        .definition-item .pos { font-style: italic; color: var(--gray); margin-right: 8px; }
        .definition-item .meaning { font-weight: 500; }
        .definition-item .example { color: #555; margin-top: 4px; font-size: 0.9em; }
        #quiz-container, #feedback-container { display: none; padding: 20px; margin-top: 20px; border: 1px solid #ddd; border-radius: 8px; }
        #quiz-word { font-size: 2em; font-weight: bold; text-align: center; margin-bottom: 20px; }
        #quiz-options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .option-btn { width: 100%; padding: 15px; background-color: #f1f1f1; color: #333; text-align: left; font-size: 1em; border-radius: 6px; border: 1px solid transparent; cursor: pointer; }
        .option-btn:hover { background-color: #e0e0e0; }
        #feedback-container { background-color: #fffbe6; border-color: #ffe58f; }
        #feedback-container.correct { background-color: #e9f7ef; border-color: #a6d9b8; }
        .feedback-actions { margin-top: 15px; }
        .file-list { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
        .file-item { background:#f7f7f7; padding:6px 8px; border-radius:6px; border:1px solid #eee; display:flex; gap:6px; align-items:center; }
        .small { font-size:0.85em; color:var(--gray); }
        .meta { display:flex; gap:10px; align-items:center; }
        .hidden-note { color: var(--red); font-weight: 600; margin-left: 8px; font-size: 0.95em; }
        .unhide-btn { background: #ffb84d; color: #000; padding: 4px 8px; border-radius: 6px; border:none; cursor:pointer; }
        .remove-btn { background: #dc3545; padding: 4px 8px; color: #fff; border-radius: 6px; border: none; cursor: pointer; }
        .note { color: var(--gray); font-size: 0.9em; margin-left: 6px; }
        #local-file-input { display:inline-block; }
    </style>
</head>
<body>
    <div class="container">
        <h1>英単語学習アプリ (複数意味対応版) — 改良版</h1>
        
        <div class="controls">
            <input type="text" id="json-files-input" value="Words_01.json" placeholder="例: Words_01.json, SWEwords_1.json">
            <button id="load-btn" class="btn-primary">🔄 読込（追加 / URL）</button>

            <label class="small note">またはローカルJSONを選択：</label>
            <input type="file" id="local-file-input" accept=".json,application/json" multiple>
            <button id="load-local-btn" class="btn-primary">📁 ローカル読み込み</button>

            <div class="file-list" id="loaded-files" title="読み込まれたファイル一覧"></div>

            <button id="export-btn" class="btn-secondary">📄 チェックした単語を保存</button>

            <div class="meta">
                <label class="small">出題数: <input type="number" id="quiz-count" min="1" value="20" style="width:80px"></label>
                <label class="small">出題対象:
                    <select id="quiz-scope">
                        <option value="unchecked">チェックリスト外 (未チェック)</option>
                        <option value="checked">チェックリスト内</option>
                        <option value="all">全て</option>
                    </select>
                </label>
                <label class="small">N(連続正解): <input type="number" id="consecutive-n" min="1" value="3" style="width:70px"></label>
                <label class="small">M(日間非表示): <input type="number" id="hide-days-m" min="0" value="7" style="width:70px"></label>
                <label class="small"><input type="checkbox" id="show-hidden"> 非表示中を表示</label>
            </div>

            <button id="start-quiz-btn" class="btn-success">🧠 4択テスト開始</button>
        </div>

        <div id="list-container">
            <h2>単語リスト (<span id="word-count">0</span>)</h2>
            <ul id="word-list"></ul>
        </div>

        <div id="quiz-container">
            <h2 id="quiz-progress">4択テスト</h2>
            <div id="quiz-word"></div>
            <div id="quiz-options"></div>
        </div>

        <div id="feedback-container">
            <h2 id="feedback-title">不正解... チェックリストに追加しました</h2>
            <div class="word-details" id="feedback-details"></div>
            <div class="feedback-actions">
                <button id="undo-check-btn" class="btn-secondary">やっぱり取り消す</button>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // DOM
    const jsonFilesInput = document.getElementById('json-files-input');
    const loadBtn = document.getElementById('load-btn');
    const loadLocalBtn = document.getElementById('load-local-btn');
    const localFileInput = document.getElementById('local-file-input');
    const exportBtn = document.getElementById('export-btn');
    const startQuizBtn = document.getElementById('start-quiz-btn');
    const wordListEl = document.getElementById('word-list');
    const wordCountEl = document.getElementById('word-count');
    const quizContainer = document.getElementById('quiz-container');
    const listContainer = document.getElementById('list-container');
    const quizProgressEl = document.getElementById('quiz-progress');
    const quizWordEl = document.getElementById('quiz-word');
    const quizOptionsEl = document.getElementById('quiz-options');
    const feedbackContainer = document.getElementById('feedback-container');
    const feedbackTitle = document.getElementById('feedback-title');
    const feedbackDetailsEl = document.getElementById('feedback-details');
    const undoCheckBtn = document.getElementById('undo-check-btn');
    const loadedFilesEl = document.getElementById('loaded-files');
    const quizCountInput = document.getElementById('quiz-count');
    const quizScopeSelect = document.getElementById('quiz-scope');
    const consecutiveNInput = document.getElementById('consecutive-n');
    const hideDaysMInput = document.getElementById('hide-days-m');
    const showHiddenCheckbox = document.getElementById('show-hidden');

    // State
    let allWords = []; // {id (string), word, checked, definitions: [...], _files: [...]} merged across files
    let filesState = []; // [{name, included:true, source: 'remote'|'local'}]
    let quizItems = []; // [{id, word, definition}]
    let currentQuizIndex = 0;
    let lastIncorrectWordId = null;

    // Persisted stats per word
    const STATS_KEY = 'englishWords_stats_v1';
    let wordStats = loadStats(); // { [id]: {consecutiveCorrect: number, hiddenUntil: timestamp|null} }

    // Events
    loadBtn.addEventListener('click', () => loadRemoteFiles());
    loadLocalBtn.addEventListener('click', () => {
        const files = Array.from(localFileInput.files || []);
        if (files.length === 0) return alert('ローカルファイルを選択してください。');
        loadLocalFiles(files);
    });
    exportBtn.addEventListener('click', exportCheckedWords);
    startQuizBtn.addEventListener('click', startQuiz);
    undoCheckBtn.addEventListener('click', undoLastCheck);
    showHiddenCheckbox.addEventListener('change', renderWordList);

    wordListEl.addEventListener('change', (e) => {
        if (e.target.type === 'checkbox' && e.target.dataset.id) {
            const wordId = String(e.target.dataset.id);
            const word = allWords.find(w => String(w.id) === wordId);
            if (word) {
                word.checked = e.target.checked;
                e.target.closest('.word-item').classList.toggle('checked', word.checked);
                persistWordsToLocal(); // optional persist of current checked state
            }
        }
    });

    // --- Functions ---

    function loadStats() {
        try {
            const raw = localStorage.getItem(STATS_KEY);
            return raw ? JSON.parse(raw) : {};
        } catch (e) {
            console.error('loadStats error', e);
            return {};
        }
    }
    function saveStats() {
        try {
            localStorage.setItem(STATS_KEY, JSON.stringify(wordStats));
        } catch (e) {
            console.error('saveStats error', e);
        }
    }
    function persistWordsToLocal() {
        // Keep checked state and basic meta in localStorage so UX is smoother across reloads
        try {
            const payload = {
                filesState,
                allWordsBasic: allWords.map(w => ({id: String(w.id), checked: !!w.checked, _files: w._files || []}))
            };
            localStorage.setItem('englishWords_local_v1', JSON.stringify(payload));
        } catch (e) { console.warn(e); }
    }
    function loadPersistedWords() {
        try {
            const raw = localStorage.getItem('englishWords_local_v1');
            if (!raw) return;
            const obj = JSON.parse(raw);
            if (obj.filesState) filesState = obj.filesState;
            if (obj.allWordsBasic) {
                obj.allWordsBasic.forEach(b => {
                    const w = allWords.find(x => String(x.id) === String(b.id));
                    if (w) {
                        w.checked = b.checked;
                        w._files = b._files || w._files || [];
                    }
                });
            }
        } catch (e) { console.warn('loadPersistedWords', e); }
    }

    // Normalize various json formats into definitions array of {pos, meaning, example}
    function normalizeDefinitions(wordObj) {
        const out = [];
        // Helper to push unique meaning
        function pushDef(pos, meaning, example) {
            meaning = (meaning === undefined || meaning === null) ? '' : String(meaning).trim();
            pos = pos || '';
            example = example || '';
            if (!out.some(d => (d.meaning || '').trim().toLowerCase() === meaning.toLowerCase())) {
                out.push({pos, meaning, example});
            }
        }

        // 1) word.definitions as array
        if (Array.isArray(wordObj.definitions)) {
            wordObj.definitions.forEach(d => {
                if (typeof d === 'string') {
                    pushDef('', d, '');
                } else if (d && typeof d === 'object') {
                    let meaning = d.meaning || d.meanings || d.def || d.text || d.gloss || '';
                    if (Array.isArray(d.meanings)) meaning = d.meanings.join('; ');
                    pushDef(d.pos || d.partOfSpeech || d.posTag || '', meaning, d.example || (Array.isArray(d.examples) ? d.examples.join(' / ') : d.examples) || '');
                }
            });
        }

        // 2) word.meanings or word.meaning (string or array)
        if (out.length === 0) {
            if (wordObj.meanings) {
                if (Array.isArray(wordObj.meanings)) {
                    wordObj.meanings.forEach(m => {
                        if (typeof m === 'string') pushDef('', m, '');
                        else if (m && typeof m === 'object') pushDef(m.pos || '', m.meaning || m.text || '', m.example || '');
                    });
                } else {
                    pushDef('', wordObj.meanings, '');
                }
            } else if (wordObj.meaning) {
                if (typeof wordObj.meaning === 'string') pushDef('', wordObj.meaning, '');
                else if (Array.isArray(wordObj.meaning)) wordObj.meaning.forEach(m => pushDef('', m, ''));
            }
        }

        // 3) word.definition (singular)
        if (out.length === 0 && wordObj.definition) {
            if (typeof wordObj.definition === 'string') pushDef('', wordObj.definition, '');
            else if (Array.isArray(wordObj.definition)) wordObj.definition.forEach(d => pushDef('', d, ''));
            else if (wordObj.definition && typeof wordObj.definition === 'object') {
                pushDef(wordObj.definition.pos || '', wordObj.definition.meaning || wordObj.definition.text || '', wordObj.definition.example || '');
            }
        }

        // 4) other known keys / fallback
        if (out.length === 0) {
            if (wordObj.gloss) pushDef('', wordObj.gloss, '');
            else if (wordObj.shortdef) {
                if (Array.isArray(wordObj.shortdef)) wordObj.shortdef.forEach(s => pushDef('', s, ''));
                else pushDef('', wordObj.shortdef, '');
            } else if (wordObj.translation) {
                if (Array.isArray(wordObj.translation)) wordObj.translation.forEach(t => pushDef('', t, ''));
                else pushDef('', wordObj.translation, '');
            }
        }

        return out;
    }

    // Merge helper: map existing allWords into a map keyed by string id
    function seedMapFromAllWords(map) {
        allWords.forEach(w => {
            map.set(String(w.id), {
                id: String(w.id),
                word: w.word || '',
                checked: !!w.checked,
                definitions: Array.isArray(w.definitions) ? w.definitions.slice() : [],
                _files: Array.isArray(w._files) ? w._files.slice() : []
            });
        });
    }

    // Load remote files (by URL or relative path). Adds new files; does not remove existing files unless user explicitly removes them.
    async function loadRemoteFiles() {
        const filenames = jsonFilesInput.value.split(',').map(f => f.trim()).filter(f => f);
        if (filenames.length === 0) return alert('ファイル名/URLを入力してください。');

        // Determine toFetch (files not already known)
        const existingNames = new Set(filesState.map(f => f.name));
        const toFetch = filenames.filter(f => !existingNames.has(f));
        // If a file name is already known but the user typed it, ensure it's marked included
        filenames.forEach(name => {
            const idx = filesState.findIndex(x => x.name === name);
            if (idx >= 0) filesState[idx].included = true;
        });

        // Fetch new ones
        const fetchResults = await Promise.allSettled(toFetch.map(f => fetch(f)));

        // Build merge map
        const map = new Map();
        seedMapFromAllWords(map);

        for (let i = 0; i < fetchResults.length; i++) {
            const fname = toFetch[i];
            const res = fetchResults[i];
            if (res.status === 'fulfilled') {
                const response = res.value;
                if (!response.ok) {
                    console.warn(`${fname} の読み込みに失敗しました。ステータス: ${response.status}`);
                    continue;
                }
                let arr;
                try {
                    arr = await response.json();
                } catch (e) {
                    console.warn(`${fname} のJSON解析に失敗しました。`, e);
                    continue;
                }
                if (!Array.isArray(arr)) {
                    console.warn(`${fname} の内容が配列ではありません。スキップします。`);
                    continue;
                }

                arr.forEach(word => {
                    if (!word) return;
                    const idKey = (typeof word.id !== 'undefined' && word.id !== null) ? String(word.id) : (`__noid__${fname}__${String(word.word||'')}`);
                    const existing = map.get(idKey);
                    const defs = normalizeDefinitions(word);

                    if (existing) {
                        defs.forEach(d => {
                            if (!existing.definitions.some(ed => (ed.meaning||'').trim().toLowerCase() === (d.meaning||'').trim().toLowerCase())) {
                                existing.definitions.push(d);
                            }
                        });
                        if (!existing._files.includes(fname)) existing._files.push(fname);
                        existing.checked = existing.checked || !!word.checked;
                        if (!existing.word && word.word) existing.word = word.word;
                    } else {
                        map.set(idKey, {
                            id: idKey,
                            word: word.word || '',
                            checked: !!word.checked,
                            definitions: defs,
                            _files: [fname]
                        });
                    }
                });
            } else {
                console.warn(`ファイル ${toFetch[i]} のフェッチでエラー:`, res.reason);
            }
        }

        // Update filesState: add fetched files (or files user typed) as included
        const prevMap = new Map(filesState.map(f => [f.name, f.included]));
        // ensure all filenames are known and included
        filenames.forEach(name => prevMap.set(name, true));
        // also add files discovered inside map (from _files)
        map.forEach(w => (w._files || []).forEach(fn => prevMap.set(fn, prevMap.get(fn) === undefined ? true : prevMap.get(fn))));

        // rebuild filesState preserving user-specified order first
        const newFilesState = [];
        const added = new Set();
        filenames.forEach(name => {
            newFilesState.push({name, included: !!prevMap.get(name), source: toFetch.includes(name) ? 'remote' : 'remote'});
            added.add(name);
        });
        filesState.forEach(f => {
            if (!added.has(f.name)) {
                newFilesState.push({name: f.name, included: !!prevMap.get(f.name), source: f.source || 'remote'});
                added.add(f.name);
            }
        });
        // add any other discovered files
        map.forEach(w => (w._files || []).forEach(fn => {
            if (!added.has(fn)) {
                newFilesState.push({name: fn, included: true, source: 'remote'});
                added.add(fn);
            }
        }));

        filesState = newFilesState;
        allWords = Array.from(map.values());
        loadPersistedWords();
        renderFilesList();
        renderWordList();
        persistWordsToLocal();

        alert(`${allWords.length}語を読み込みました（新規ファイル: ${toFetch.length} 件）。`);
    }

    // Load local File objects (from input). These are given a name and 'local' source.
    async function loadLocalFiles(files) {
        const map = new Map();
        seedMapFromAllWords(map);

        for (const file of files) {
            let txt;
            try {
                txt = await file.text();
            } catch (e) {
                console.warn(`${file.name} の読み込みに失敗しました。`, e);
                continue;
            }
            let arr;
            try {
                arr = JSON.parse(txt);
            } catch (e) {
                console.warn(`${file.name} のJSON解析に失敗しました。`, e);
                continue;
            }
            if (!Array.isArray(arr)) {
                console.warn(`${file.name} の内容が配列ではありません。スキップします。`);
                continue;
            }
            arr.forEach(word => {
                if (!word) return;
                const fname = file.name;
                const idKey = (typeof word.id !== 'undefined' && word.id !== null) ? String(word.id) : (`__noid__${fname}__${String(word.word||'')}`);
                const existing = map.get(idKey);
                const defs = normalizeDefinitions(word);

                if (existing) {
                    defs.forEach(d => {
                        if (!existing.definitions.some(ed => (ed.meaning||'').trim().toLowerCase() === (d.meaning||'').trim().toLowerCase())) {
                            existing.definitions.push(d);
                        }
                    });
                    if (!existing._files.includes(fname)) existing._files.push(fname);
                    existing.checked = existing.checked || !!word.checked;
                    if (!existing.word && word.word) existing.word = word.word;
                } else {
                    map.set(idKey, {
                        id: idKey,
                        word: word.word || '',
                        checked: !!word.checked,
                        definitions: defs,
                        _files: [fname]
                    });
                }
            });
        }

        // Update filesState: add local files (marked as included by default)
        const prevMap = new Map(filesState.map(f => [f.name, f.included]));
        Array.from(files).forEach(file => prevMap.set(file.name, true));
        // rebuild filesState: keep previous order, then add new local files if needed
        const newFilesState = [];
        const added = new Set();
        // First add previously-known files (preserve order)
        filesState.forEach(f => {
            newFilesState.push({name: f.name, included: !!prevMap.get(f.name), source: f.source || 'remote'});
            added.add(f.name);
        });
        // Then add new local files
        Array.from(files).forEach(file => {
            if (!added.has(file.name)) {
                newFilesState.push({name: file.name, included: true, source: 'local'});
                added.add(file.name);
            }
        });
        // Also add any discovered file names from data
        map.forEach(w => (w._files || []).forEach(fn => {
            if (!added.has(fn)) {
                newFilesState.push({name: fn, included: true, source: 'local'});
                added.add(fn);
            }
        }));

        filesState = newFilesState;
        allWords = Array.from(map.values());
        loadPersistedWords();
        renderFilesList();
        renderWordList();
        persistWordsToLocal();

        alert(`ローカルファイル ${files.length} 件を読み込みました。`);
    }

    function renderFilesList() {
        loadedFilesEl.innerHTML = '';
        filesState.forEach((f, idx) => {
            const div = document.createElement('div');
            div.className = 'file-item';
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.checked = !!f.included;
            cb.title = 'このファイルを表示の対象に含める / 除外する';
            cb.addEventListener('change', () => {
                filesState[idx].included = cb.checked;
                renderWordList();
                persistWordsToLocal();
            });
            const label = document.createElement('span');
            label.textContent = `${f.name} ${f.source ? '(' + f.source + ')' : ''}`;
            label.style.maxWidth = '260px';
            label.style.overflow = 'hidden';
            label.style.textOverflow = 'ellipsis';
            label.style.whiteSpace = 'nowrap';
            const excludeBtn = document.createElement('button');
            excludeBtn.className = 'unhide-btn';
            excludeBtn.textContent = f.included ? '除外' : '含める';
            excludeBtn.onclick = () => {
                filesState[idx].included = !filesState[idx].included;
                cb.checked = filesState[idx].included;
                excludeBtn.textContent = filesState[idx].included ? '除外' : '含める';
                renderWordList();
                persistWordsToLocal();
            };
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.textContent = '削除';
            removeBtn.title = '読み込んだファイルを完全に取り除きます（そのファイルのみが持つ単語は消えます）';
            removeBtn.onclick = () => {
                if (!confirm(`${f.name} を完全に削除しますか？ このファイル由来の単語で他に参照がないものはリストから削除されます。`)) return;
                removeFileAndItsWords(f.name);
            };

            div.appendChild(cb);
            div.appendChild(label);
            div.appendChild(excludeBtn);
            div.appendChild(removeBtn);
            loadedFilesEl.appendChild(div);
        });
    }

    function removeFileAndItsWords(fname) {
        // Remove file from filesState
        filesState = filesState.filter(f => f.name !== fname);
        // Remove file from _files arrays and remove words that have no files left
        allWords = allWords.filter(w => {
            w._files = (w._files || []).filter(fn => fn !== fname);
            return (w._files && w._files.length > 0) || (w._files && w._files.length === 0 && w._manual); // keep manual words if any
        });
        // Persist and rerender
        persistWordsToLocal();
        renderFilesList();
        renderWordList();
    }

    function isFileIncluded(fname) {
        const f = filesState.find(x => x.name === fname);
        return f ? !!f.included : true;
    }

    // Render words: respects file include/exclude and per-word hiddenUntil, and showHidden checkbox
    function renderWordList() {
        wordListEl.innerHTML = '';
        const showHidden = showHiddenCheckbox.checked;
        // sort alphabetically
        allWords.sort((a, b) => (a.word || '').localeCompare(b.word || ''));
        const now = Date.now();

        const visibleWords = allWords.filter(w => {
            const files = w._files || [];
            const included = files.length === 0 ? true : files.some(isFileIncluded);
            if (!included) return false;
            const stats = wordStats[String(w.id)];
            const hiddenUntil = stats && stats.hiddenUntil ? stats.hiddenUntil : null;
            if (hiddenUntil && hiddenUntil > now) {
                return showHidden; // show only if showHidden true
            }
            return true;
        });

        visibleWords.forEach(word => {
            const stats = wordStats[String(word.id)] || {consecutiveCorrect: 0, hiddenUntil: null};
            const isHidden = stats.hiddenUntil && stats.hiddenUntil > Date.now();
            const li = document.createElement('li');
            li.className = 'word-item' + (word.checked ? ' checked' : '') + (isHidden ? ' hidden' : '');
            let definitionsHtml = '';
            (word.definitions || []).forEach(def => {
                definitionsHtml += `
                    <div class="definition-item">
                        <div>
                            <span class="pos">${escapeHtml(def.pos)}</span>
                            <span class="meaning">${escapeHtml(def.meaning)}</span>
                        </div>
                        <div class="example">例: ${escapeHtml(def.example)}</div>
                    </div>
                `;
            });

            // Unhide button (visible only when hidden)
            const unhideButtonHtml = isHidden ? `<button class="unhide-btn" data-id="${escapeHtml(String(word.id))}">非表示解除</button>` : '';

            li.innerHTML = `
                <input type="checkbox" data-id="${escapeHtml(String(word.id))}" ${word.checked ? 'checked' : ''}>
                <div class="word-details">
                    <div><span class="word">${escapeHtml(word.word)}</span> ${isHidden ? '<span class="hidden-note">（非表示中）</span>' : ''}</div>
                    <div class="small">ファイル: ${escapeHtml((word._files||[]).join(', '))} / 連続正解: ${stats.consecutiveCorrect || 0}</div>
                    ${definitionsHtml}
                </div>
                <div>
                    ${unhideButtonHtml}
                </div>
            `;
            wordListEl.appendChild(li);

            if (isHidden) {
                const btn = li.querySelector('button.unhide-btn');
                if (btn) {
                    btn.addEventListener('click', () => {
                        if (!wordStats[String(word.id)]) wordStats[String(word.id)] = {consecutiveCorrect: 0, hiddenUntil: null};
                        wordStats[String(word.id)].hiddenUntil = null;
                        wordStats[String(word.id)].consecutiveCorrect = 0;
                        saveStats();
                        renderWordList();
                    });
                }
            }
        });

        wordCountEl.textContent = visibleWords.length;
    }

    function escapeHtml(str) {
        if (str === undefined || str === null) return '';
        return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[s]);
    }

    // Export checked words (only those from included files)
    function exportCheckedWords() {
        const checkedWords = allWords.filter(w => w.checked && (w._files || []).some(isFileIncluded));
        if (checkedWords.length === 0) return alert('エクスポートする単語がありません。');
        const jsonString = JSON.stringify(checkedWords, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        a.download = `CheckWords_${timestamp}.json`;
        a.href = url;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // Start quiz
    function startQuiz() {
        const scope = quizScopeSelect.value; // 'unchecked' | 'checked' | 'all'
        const nQuestions = Math.max(1, parseInt(quizCountInput.value) || 1);
        const N = Math.max(1, parseInt(consecutiveNInput.value) || 1);
        const M = Math.max(0, parseInt(hideDaysMInput.value) || 0);
        const now = Date.now();

        const poolWords = allWords.filter(w => {
            const files = w._files || [];
            const included = files.length === 0 ? true : files.some(isFileIncluded);
            if (!included) return false;
            const stats = wordStats[String(w.id)] || {};
            if (stats.hiddenUntil && stats.hiddenUntil > now) return false; // skip hidden
            if (scope === 'checked') return !!w.checked;
            if (scope === 'unchecked') return !w.checked;
            return true;
        });

        // Build quiz items as definition-level items
        quizItems = [];
        poolWords.forEach(word => {
            (word.definitions || []).forEach(def => {
                if (def && (def.meaning || '').trim() !== '') {
                    quizItems.push({ id: word.id, word: word.word, definition: def });
                }
            });
        });

        if (quizItems.length < 4) {
            return alert('テストを行うには、対象となる単語（意味ペア）が4つ以上必要です。フィルターや非表示設定を確認してください。');
        }

        shuffleArray(quizItems);
        if (quizItems.length > nQuestions) quizItems = quizItems.slice(0, nQuestions);
        quizMeta = { N, M };

        currentQuizIndex = 0;
        listContainer.style.display = 'none';
        feedbackContainer.style.display = 'none';
        quizContainer.style.display = 'block';
        displayQuizQuestion();
    }

    function displayQuizQuestion() {
        if (currentQuizIndex >= quizItems.length) {
            alert('テスト終了です！お疲れ様でした。');
            listContainer.style.display = 'block';
            quizContainer.style.display = 'none';
            renderWordList();
            saveStats();
            return;
        }

        const currentQuizItem = quizItems[currentQuizIndex];
        const correctAnswerDef = currentQuizItem.definition;

        quizProgressEl.textContent = `4択テスト (${currentQuizIndex + 1} / ${quizItems.length})`;
        quizWordEl.textContent = currentQuizItem.word;

        // Build options: correct + 3 distractors (different meanings)
        let options = [correctAnswerDef];
        const triesMax = 1000;
        let tries = 0;
        while (options.length < 4 && tries < triesMax) {
            tries++;
            const randomWord = allWords[Math.floor(Math.random() * allWords.length)];
            const defs = randomWord.definitions || [];
            if (defs.length === 0) continue;
            const randomDef = defs[Math.floor(Math.random() * defs.length)];
            if (!randomDef || !(randomDef.meaning||'').trim()) continue;
            if (!options.some(opt => (opt.meaning||'').trim().toLowerCase() === (randomDef.meaning||'').trim().toLowerCase())) {
                options.push(randomDef);
            }
        }
        while (options.length < 4) options.push({pos:'', meaning: '(選択肢不足)', example:''});

        shuffleArray(options);

        quizOptionsEl.innerHTML = '';
        options.forEach(opt => {
            const button = document.createElement('button');
            button.className = 'option-btn';
            button.innerHTML = `<div class="meaning">${escapeHtml(opt.meaning)}</div><div class="small">${escapeHtml(opt.pos)}</div>`;
            button.onclick = () => handleAnswer((opt.meaning||'').trim() === (correctAnswerDef.meaning||'').trim(), currentQuizItem);
            quizOptionsEl.appendChild(button);
        });
    }

    // Handle answer (auto-advance on correct)
    let quizMeta = { N: 3, M: 7 };
    function handleAnswer(isCorrect, quizItem) {
        const wordId = String(quizItem.id);
        if (isCorrect) {
            if (!wordStats[wordId]) wordStats[wordId] = {consecutiveCorrect: 0, hiddenUntil: null};
            wordStats[wordId].consecutiveCorrect = (wordStats[wordId].consecutiveCorrect || 0) + 1;
            if (wordStats[wordId].consecutiveCorrect >= (quizMeta.N || 1)) {
                if (quizMeta.M && quizMeta.M > 0) {
                    const days = quizMeta.M;
                    const until = Date.now() + days * 24 * 60 * 60 * 1000;
                    wordStats[wordId].hiddenUntil = until;
                }
                wordStats[wordId].consecutiveCorrect = 0;
            }
            saveStats();
            currentQuizIndex++;
            displayQuizQuestion();
        } else {
            const originalWord = allWords.find(w => String(w.id) === wordId);
            if (originalWord) {
                originalWord.checked = true;
                lastIncorrectWordId = String(originalWord.id);
                if (!wordStats[wordId]) wordStats[wordId] = {consecutiveCorrect: 0, hiddenUntil: null};
                wordStats[wordId].consecutiveCorrect = 0;
                saveStats();

                feedbackTitle.textContent = '不正解... チェックリストに追加しました';
                let definitionsHtml = '';
                originalWord.definitions.forEach(def => {
                    const isIncorrectDef = (def.meaning || '').trim() === (quizItem.definition.meaning || '').trim();
                    definitionsHtml += `
                        <div class="definition-item" style="${isIncorrectDef ? 'font-weight:bold; color:var(--red);' : ''}">
                            <div>
                                <span class="pos">${escapeHtml(def.pos)}</span>
                                <span class="meaning">${escapeHtml(def.meaning)}</span>
                            </div>
                            <div class="example">例: ${escapeHtml(def.example)}</div>
                        </div>
                    `;
                });

                feedbackDetailsEl.innerHTML = `
                    <div><span class="word">${escapeHtml(originalWord.word)}</span></div>
                    ${definitionsHtml}
                `;
                feedbackContainer.style.display = 'block';
            } else {
                currentQuizIndex++;
                displayQuizQuestion();
            }
            renderWordList();
        }
    }

    function undoLastCheck() {
        if (lastIncorrectWordId !== null) {
            const word = allWords.find(w => String(w.id) === String(lastIncorrectWordId));
            if (word) {
                word.checked = false;
                lastIncorrectWordId = null;
                feedbackContainer.style.display = 'none';
                persistWordsToLocal();
                renderWordList();
                alert(`「${word.word}」のチェックを取り消しました。`);
            }
        }
    }

    // Utility: Fisher-Yates shuffle
    function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }

    // Load previously persisted stats and optionally persisted local word meta
    (function initialLoad() {
        const rawLocal = localStorage.getItem('englishWords_local_v1');
        if (rawLocal) {
            try {
                const obj = JSON.parse(rawLocal);
                if (obj.filesState) filesState = obj.filesState;
            } catch (e) { /* ignore */ }
        }
    })();

    // Start by auto-loading filenames in input (if possible)
    // Note: This will attempt to fetch the filename(s) in the input. If your SWEwords_1.json is a local file on your PC,
    // the browser cannot fetch it by name; instead use the ファイル選択 (ローカル読み込み) to load it.
    loadRemoteFiles();
});
</script>
</body>
</html>
