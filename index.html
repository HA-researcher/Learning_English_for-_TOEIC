<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>英単語学習アプリ (複数意味対応版) — 改良v1.2</title>
    <style>
        :root { --main-color: #007bff; --light-gray: #f8f9fa; --gray: #6c757d; --red: #dc3545; --green: #28a745; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; background-color: var(--light-gray); display: flex; justify-content: center; }
        .container { width: 100%; max-width: 1000px; background-color: #fff; margin: 20px; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1, h2 { color: #333; text-align: center; }
        .controls, .quiz-controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 20px; align-items: center; }
        .controls input[type="text"], .controls input[type="number"], .controls select { padding: 8px; border: 1px solid #ccc; border-radius: 4px; min-width: 120px; }
        button { padding: 10px 15px; border: none; border-radius: 4px; color: #fff; cursor: pointer; transition: background-color 0.2s; }
        .btn-primary { background-color: var(--main-color); }
        .btn-primary:hover { background-color: #0056b3; }
        .btn-secondary { background-color: var(--gray); }
        .btn-secondary:hover { background-color: #5a6268; }
        .btn-success { background-color: var(--green); }
        .btn-success:hover { background-color: #218838; }
        #word-list { list-style: none; padding: 0; max-height: 400px; overflow-y: auto; border-top: 1px solid #eee; margin-top: 10px; }
        .word-item { display: flex; align-items: flex-start; gap: 10px; padding: 10px; border-bottom: 1px solid #eee; }
        .word-item.hidden { opacity: 0.4; }
        .word-item.checked { background-color: #e9f5ff; }
        .word-item input[type="checkbox"] { margin-top: 5px; width: 18px; height: 18px; flex-shrink: 0; }
        .word-details { flex-grow: 1; }
        .word-details .word { font-size: 1.2em; font-weight: bold; }
        .definition-item { margin-top: 8px; margin-left: 10px; }
        .definition-item .pos { font-style: italic; color: var(--gray); margin-right: 8px; }
        .definition-item .meaning { font-weight: 500; }
        .definition-item .example { color: #555; margin-top: 4px; font-size: 0.9em; }
        #quiz-container, #feedback-container { display: none; padding: 20px; margin-top: 20px; border: 1px solid #ddd; border-radius: 8px; }
        #quiz-word { font-size: 2em; font-weight: bold; text-align: center; margin-bottom: 20px; }
        #quiz-options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .option-btn { width: 100%; padding: 15px; background-color: #f1f1f1; color: #333; text-align: left; font-size: 1em; border-radius: 6px; border: 1px solid transparent; cursor: pointer; }
        .option-btn:hover { background-color: #e0e0e0; }
        #feedback-container { background-color: #fffbe6; border-color: #ffe58f; }
        #feedback-container.correct { background-color: #e9f7ef; border-color: #a6d9b8; }
        .feedback-actions { margin-top: 15px; }
        .file-list { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
        .file-item { background:#f7f7f7; padding:6px 8px; border-radius:6px; border:1px solid #eee; display:flex; gap:6px; align-items:center; }
        .small { font-size:0.85em; color:var(--gray); }
        .meta { display:flex; gap:10px; align-items:center; }
        .hidden-note { color: var(--red); font-weight: 600; margin-left: 8px; font-size: 0.95em; }
        .unhide-btn { background: #ffb84d; color: #000; padding: 4px 8px; border-radius: 6px; border:none; cursor:pointer; }
    </style>
</head>
<body>
    <div class="container">
        <h1>英単語学習アプリ (複数意味対応版) — 改良版</h1>
        
        <div class="controls">
            <input type="text" id="json-files-input" value="Words_01.json" placeholder="例: Words_01.json, SWEwords_1.json">
            <button id="load-btn" class="btn-primary">🔄 読込（追加）</button>
            <div class="file-list" id="loaded-files"></div>

            <button id="export-btn" class="btn-secondary">📄 チェックした単語を保存</button>

            <div class="meta">
                <label class="small">出題数: <input type="number" id="quiz-count" min="1" value="20" style="width:80px"></label>
                <label class="small">出題対象:
                    <select id="quiz-scope">
                        <option value="unchecked">チェックリスト外 (未チェック)</option>
                        <option value="checked">チェックリスト内</option>
                        <option value="all">全て</option>
                    </select>
                </label>
                <label class="small">N(連続正解): <input type="number" id="consecutive-n" min="1" value="3" style="width:70px"></label>
                <label class="small">M(日間非表示): <input type="number" id="hide-days-m" min="0" value="7" style="width:70px"></label>
                <label class="small"><input type="checkbox" id="show-hidden"> 非表示中を表示</label>
            </div>

            <button id="start-quiz-btn" class="btn-success">🧠 4択テスト開始</button>
        </div>

        <div id="list-container">
            <h2>単語リスト (<span id="word-count">0</span>)</h2>
            <ul id="word-list"></ul>
        </div>

        <div id="quiz-container">
            <h2 id="quiz-progress">4択テスト</h2>
            <div id="quiz-word"></div>
            <div id="quiz-options"></div>
        </div>

        <div id="feedback-container">
            <h2 id="feedback-title">不正解... チェックリストに追加しました</h2>
            <div class="word-details" id="feedback-details"></div>
            <div class="feedback-actions">
                <button id="undo-check-btn" class="btn-secondary">やっぱり取り消す</button>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // DOM
    const jsonFilesInput = document.getElementById('json-files-input');
    const loadBtn = document.getElementById('load-btn');
    const exportBtn = document.getElementById('export-btn');
    const startQuizBtn = document.getElementById('start-quiz-btn');
    const wordListEl = document.getElementById('word-list');
    const wordCountEl = document.getElementById('word-count');
    const quizContainer = document.getElementById('quiz-container');
    const listContainer = document.getElementById('list-container');
    const quizProgressEl = document.getElementById('quiz-progress');
    const quizWordEl = document.getElementById('quiz-word');
    const quizOptionsEl = document.getElementById('quiz-options');
    const feedbackContainer = document.getElementById('feedback-container');
    const feedbackTitle = document.getElementById('feedback-title');
    const feedbackDetailsEl = document.getElementById('feedback-details');
    const undoCheckBtn = document.getElementById('undo-check-btn');
    const loadedFilesEl = document.getElementById('loaded-files');
    const quizCountInput = document.getElementById('quiz-count');
    const quizScopeSelect = document.getElementById('quiz-scope');
    const consecutiveNInput = document.getElementById('consecutive-n');
    const hideDaysMInput = document.getElementById('hide-days-m');
    const showHiddenCheckbox = document.getElementById('show-hidden');

    // State
    let allWords = []; // {id (string), word, checked, definitions: [...], _files: [...]} merged across files
    let filesState = []; // [{name, included:true}]
    let quizItems = []; // [{id, word, definition}]
    let currentQuizIndex = 0;
    let lastIncorrectWordId = null;

    // Persisted stats per word
    const STATS_KEY = 'englishWords_stats_v1';
    let wordStats = loadStats(); // { [id]: {consecutiveCorrect: number, hiddenUntil: timestamp|null} }

    // Events
    loadBtn.addEventListener('click', () => loadWords({mode: 'append'}));
    exportBtn.addEventListener('click', exportCheckedWords);
    startQuizBtn.addEventListener('click', startQuiz);
    undoCheckBtn.addEventListener('click', undoLastCheck);
    showHiddenCheckbox.addEventListener('change', renderWordList);

    wordListEl.addEventListener('change', (e) => {
        if (e.target.type === 'checkbox' && e.target.dataset.id) {
            const wordId = String(e.target.dataset.id);
            const word = allWords.find(w => String(w.id) === wordId);
            if (word) {
                word.checked = e.target.checked;
                e.target.closest('.word-item').classList.toggle('checked', word.checked);
                persistWordsToLocal(); // optional persist of current checked state
            }
        }
    });

    // --- Functions ---

    function loadStats() {
        try {
            const raw = localStorage.getItem(STATS_KEY);
            return raw ? JSON.parse(raw) : {};
        } catch (e) {
            console.error('loadStats error', e);
            return {};
        }
    }
    function saveStats() {
        try {
            localStorage.setItem(STATS_KEY, JSON.stringify(wordStats));
        } catch (e) {
            console.error('saveStats error', e);
        }
    }
    function persistWordsToLocal() {
        // Keep checked state and basic meta in localStorage so UX is smoother across reloads
        try {
            const payload = {
                filesState,
                allWordsBasic: allWords.map(w => ({id: String(w.id), checked: !!w.checked, _files: w._files || []}))
            };
            localStorage.setItem('englishWords_local_v1', JSON.stringify(payload));
        } catch (e) { console.warn(e); }
    }
    function loadPersistedWords() {
        try {
            const raw = localStorage.getItem('englishWords_local_v1');
            if (!raw) return;
            const obj = JSON.parse(raw);
            if (obj.filesState) filesState = obj.filesState;
            if (obj.allWordsBasic) {
                obj.allWordsBasic.forEach(b => {
                    const w = allWords.find(x => String(x.id) === String(b.id));
                    if (w) {
                        w.checked = b.checked;
                        w._files = b._files || w._files || [];
                    }
                });
            }
        } catch (e) { console.warn('loadPersistedWords', e); }
    }

    // Normalize various json formats into definitions array of {pos, meaning, example}
    function normalizeDefinitions(wordObj) {
        const out = [];
        // Helper to push unique meaning
        function pushDef(pos, meaning, example) {
            meaning = (meaning === undefined || meaning === null) ? '' : String(meaning).trim();
            pos = pos || '';
            example = example || '';
            if (!out.some(d => (d.meaning || '').trim().toLowerCase() === meaning.toLowerCase())) {
                out.push({pos, meaning, example});
            }
        }

        // 1) word.definitions as array
        if (Array.isArray(wordObj.definitions)) {
            wordObj.definitions.forEach(d => {
                if (typeof d === 'string') {
                    pushDef('', d, '');
                } else if (d && typeof d === 'object') {
                    // Some JSON may use 'meaning' or 'meanings' or 'def' keys
                    let meaning = d.meaning || d.meanings || d.def || d.text || '';
                    // if d.meanings is array, join with '; '
                    if (Array.isArray(d.meanings)) meaning = d.meanings.join('; ');
                    pushDef(d.pos || d.partOfSpeech || '', meaning, d.example || d.examples || '');
                }
            });
        }

        // 2) word.meanings or word.meaning (string or array)
        if (out.length === 0) {
            if (wordObj.meanings) {
                if (Array.isArray(wordObj.meanings)) {
                    wordObj.meanings.forEach(m => {
                        if (typeof m === 'string') pushDef('', m, '');
                        else if (m && typeof m === 'object') pushDef(m.pos || '', m.meaning || m.text || '', m.example || '');
                    });
                } else {
                    pushDef('', wordObj.meanings, '');
                }
            } else if (wordObj.meaning) {
                if (typeof wordObj.meaning === 'string') pushDef('', wordObj.meaning, '');
                else if (Array.isArray(wordObj.meaning)) wordObj.meaning.forEach(m => pushDef('', m, ''));
            }
        }

        // 3) word.definition (singular)
        if (out.length === 0 && wordObj.definition) {
            if (typeof wordObj.definition === 'string') pushDef('', wordObj.definition, '');
            else if (Array.isArray(wordObj.definition)) wordObj.definition.forEach(d => pushDef('', d, ''));
            else if (wordObj.definition && typeof wordObj.definition === 'object') {
                pushDef(wordObj.definition.pos || '', wordObj.definition.meaning || wordObj.definition.text || '', wordObj.definition.example || '');
            }
        }

        // 4) fallback: if there are keys like gloss, shortdef
        if (out.length === 0) {
            if (wordObj.gloss) pushDef('', wordObj.gloss, '');
            else if (wordObj.shortdef) {
                if (Array.isArray(wordObj.shortdef)) wordObj.shortdef.forEach(s => pushDef('', s, ''));
                else pushDef('', wordObj.shortdef, '');
            }
        }

        return out;
    }

    // Load (append) multiple JSON files, merge words (by id), track file origin and allow exclude
    async function loadWords({mode = 'append'} = {}) {
        const filenames = jsonFilesInput.value.split(',').map(f => f.trim()).filter(f => f);
        if (filenames.length === 0) return alert('ファイル名を入力してください。');

        try {
            // Determine which files are new (not yet known) and which are already in filesState
            const existingNames = new Set(filesState.map(f => f.name));
            const toFetch = filenames.filter(f => !existingNames.has(f));
            const markIncluded = filenames; // filenames mentioned will be marked included

            // Fetch new files (if any). Use Promise.allSettled so one bad file doesn't cancel others.
            const fetchResults = await Promise.allSettled(toFetch.map(f => fetch(f)));

            // Map for merging: start from existing allWords (preserve previously loaded words)
            const map = new Map();
            // seed map with existing words keyed by string id
            allWords.forEach(w => {
                map.set(String(w.id), {
                    id: String(w.id),
                    word: w.word || '',
                    checked: !!w.checked,
                    definitions: Array.isArray(w.definitions) ? w.definitions.slice() : [],
                    _files: Array.isArray(w._files) ? w._files.slice() : []
                });
            });

            // Process fetched results
            for (let i = 0; i < fetchResults.length; i++) {
                const fname = toFetch[i];
                const res = fetchResults[i];
                if (res.status === 'fulfilled') {
                    const response = res.value;
                    if (!response.ok) {
                        console.warn(`${fname} の読み込みに失敗しました。ステータス: ${response.status}`);
                        continue;
                    }
                    let arr;
                    try {
                        arr = await response.json();
                    } catch (e) {
                        console.warn(`${fname} のJSON解析に失敗しました。`, e);
                        continue;
                    }
                    if (!Array.isArray(arr)) {
                        console.warn(`${fname} の内容が配列ではありません。スキップします。`);
                        continue;
                    }

                    arr.forEach(word => {
                        if (!word || typeof word === 'undefined') return;
                        // use string id (to support non-numeric ids). If id missing, try to use word text + file as key
                        const idKey = (typeof word.id !== 'undefined' && word.id !== null) ? String(word.id) : (`__noid__${fname}__${String(word.word||'')}`);
                        const existing = map.get(idKey);
                        const defs = normalizeDefinitions(word);

                        if (existing) {
                            // merge definitions (avoid duplicate meanings)
                            defs.forEach(d => {
                                if (!existing.definitions.some(ed => (ed.meaning||'').trim().toLowerCase() === (d.meaning||'').trim().toLowerCase())) {
                                    existing.definitions.push(d);
                                }
                            });
                            if (!existing._files.includes(fname)) existing._files.push(fname);
                            // prefer existing checked:true if already set, otherwise take word.checked
                            existing.checked = existing.checked || !!word.checked;
                            // prefer non-empty word text
                            if (!existing.word && word.word) existing.word = word.word;
                        } else {
                            map.set(idKey, {
                                id: idKey,
                                word: word.word || '',
                                checked: !!word.checked,
                                definitions: defs,
                                _files: [fname]
                            });
                        }
                    });
                } else {
                    console.warn(`ファイル ${toFetch[i]} のフェッチでエラー:`, res.reason);
                }
            }

            // Also, if user included some filenames that were already present, ensure they are marked included
            // Update filesState: preserve existing entries, add new ones as included by default
            const prevMap = new Map(filesState.map(f => [f.name, f.included]));
            filenames.forEach(name => {
                // if previously existed, set to true (since user requested it), otherwise add as true
                prevMap.set(name, true);
            });
            // Add any previously-known files that user didn't mention (preserve their included flag)
            filesState.forEach(f => {
                if (!prevMap.has(f.name)) prevMap.set(f.name, f.included);
            });
            // rebuild filesState preserving order: first the filenames user supplied, then others
            const newFilesState = [];
            const added = new Set();
            // add filenames user mentioned first
            filenames.forEach(name => {
                newFilesState.push({name, included: !!prevMap.get(name)});
                added.add(name);
            });
            // then add remaining files from prev filesState
            filesState.forEach(f => {
                if (!added.has(f.name)) {
                    newFilesState.push({name: f.name, included: !!prevMap.get(f.name)});
                    added.add(f.name);
                }
            });
            // finally, add any other files that were fetched but not previously in filesState or mentioned
            map.forEach(w => {
                (w._files || []).forEach(fn => {
                    if (!added.has(fn)) {
                        newFilesState.push({name: fn, included: true});
                        added.add(fn);
                    }
                });
            });

            filesState = newFilesState;

            allWords = Array.from(map.values());
            // restore persisted small bits (checked state) if present (matching by id string)
            loadPersistedWords();

            renderFilesList();
            renderWordList();
            persistWordsToLocal();

            alert(`${allWords.length}語（定義単位ではなく単語数）を読み込みました。新規ファイル: ${toFetch.length} 件。`);
        } catch (error) {
            alert(`エラー: ${error.message}`);
            console.error(error);
        }
    }

    function renderFilesList() {
        loadedFilesEl.innerHTML = '';
        filesState.forEach(f => {
            const div = document.createElement('div');
            div.className = 'file-item';
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.checked = !!f.included;
            cb.addEventListener('change', () => {
                f.included = cb.checked;
                renderWordList();
                persistWordsToLocal();
            });
            const label = document.createElement('span');
            label.textContent = f.name;
            const excludeBtn = document.createElement('button');
            excludeBtn.className = 'unhide-btn';
            excludeBtn.textContent = f.included ? '除外する' : '含める';
            excludeBtn.onclick = () => {
                f.included = !f.included;
                cb.checked = f.included;
                excludeBtn.textContent = f.included ? '除外する' : '含める';
                renderWordList();
                persistWordsToLocal();
            };
            div.appendChild(cb);
            div.appendChild(label);
            div.appendChild(excludeBtn);
            loadedFilesEl.appendChild(div);
        });
    }

    function isFileIncluded(fname) {
        const f = filesState.find(x => x.name === fname);
        return f ? !!f.included : true;
    }

    // Render words: respects file include/exclude and per-word hiddenUntil, and showHidden checkbox
    function renderWordList() {
        wordListEl.innerHTML = '';
        const showHidden = showHiddenCheckbox.checked;
        // sort alphabetically
        allWords.sort((a, b) => (a.word || '').localeCompare(b.word || ''));
        const now = Date.now();

        const visibleWords = allWords.filter(w => {
            // if word has no file info, include it
            const files = w._files || [];
            const included = files.length === 0 ? true : files.some(isFileIncluded);
            if (!included) return false;
            const stats = wordStats[String(w.id)];
            const hiddenUntil = stats && stats.hiddenUntil ? stats.hiddenUntil : null;
            if (hiddenUntil && hiddenUntil > now) {
                return showHidden; // show only if showHidden true
            }
            return true;
        });

        visibleWords.forEach(word => {
            const stats = wordStats[String(word.id)] || {consecutiveCorrect: 0, hiddenUntil: null};
            const isHidden = stats.hiddenUntil && stats.hiddenUntil > Date.now();
            const li = document.createElement('li');
            li.className = 'word-item' + (word.checked ? ' checked' : '') + (isHidden ? ' hidden' : '');
            let definitionsHtml = '';
            (word.definitions || []).forEach(def => {
                definitionsHtml += `
                    <div class="definition-item">
                        <div>
                            <span class="pos">${escapeHtml(def.pos)}</span>
                            <span class="meaning">${escapeHtml(def.meaning)}</span>
                        </div>
                        <div class="example">例: ${escapeHtml(def.example)}</div>
                    </div>
                `;
            });

            // Unhide button (visible only when hidden)
            const unhideButtonHtml = isHidden ? `<button class="unhide-btn" data-id="${escapeHtml(String(word.id))}">非表示解除</button>` : '';

            li.innerHTML = `
                <input type="checkbox" data-id="${escapeHtml(String(word.id))}" ${word.checked ? 'checked' : ''}>
                <div class="word-details">
                    <div><span class="word">${escapeHtml(word.word)}</span> ${isHidden ? '<span class="hidden-note">（非表示中）</span>' : ''}</div>
                    <div class="small">ファイル: ${escapeHtml((word._files||[]).join(', '))} / 連続正解: ${stats.consecutiveCorrect || 0}</div>
                    ${definitionsHtml}
                </div>
                <div>
                    ${unhideButtonHtml}
                </div>
            `;
            wordListEl.appendChild(li);

            if (isHidden) {
                const btn = li.querySelector('button.unhide-btn');
                if (btn) {
                    btn.addEventListener('click', () => {
                        if (!wordStats[String(word.id)]) wordStats[String(word.id)] = {consecutiveCorrect: 0, hiddenUntil: null};
                        wordStats[String(word.id)].hiddenUntil = null;
                        wordStats[String(word.id)].consecutiveCorrect = 0;
                        saveStats();
                        renderWordList();
                    });
                }
            }
        });

        wordCountEl.textContent = visibleWords.length;
    }

    function escapeHtml(str) {
        if (str === undefined || str === null) return '';
        return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[s]);
    }

    // Export checked words (only those from included files)
    function exportCheckedWords() {
        const checkedWords = allWords.filter(w => w.checked && (w._files || []).some(isFileIncluded));
        if (checkedWords.length === 0) return alert('エクスポートする単語がありません。');
        const jsonString = JSON.stringify(checkedWords, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        a.download = `CheckWords_${timestamp}.json`;
        a.href = url;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // Start quiz
    function startQuiz() {
        // Build pool according to scope and file inclusion and hidden state
        const scope = quizScopeSelect.value; // 'unchecked' | 'checked' | 'all'
        const nQuestions = Math.max(1, parseInt(quizCountInput.value) || 1);
        const N = Math.max(1, parseInt(consecutiveNInput.value) || 1);
        const M = Math.max(0, parseInt(hideDaysMInput.value) || 0);
        const now = Date.now();

        // Filter words by files included and hiddenUntil
        const poolWords = allWords.filter(w => {
            const files = w._files || [];
            const included = files.length === 0 ? true : files.some(isFileIncluded);
            if (!included) return false;
            const stats = wordStats[String(w.id)] || {};
            if (stats.hiddenUntil && stats.hiddenUntil > now) return false; // skip hidden
            if (scope === 'checked') return !!w.checked;
            if (scope === 'unchecked') return !w.checked;
            return true;
        });

        // Build quiz items as definition-level items
        quizItems = [];
        poolWords.forEach(word => {
            (word.definitions || []).forEach(def => {
                // only include meaningful definitions
                if (def && (def.meaning || '').trim() !== '') {
                    quizItems.push({ id: word.id, word: word.word, definition: def });
                }
            });
        });

        if (quizItems.length < 4) {
            return alert('テストを行うには、対象となる単語（意味ペア）が4つ以上必要です。フィルターや非表示設定を確認してください。');
        }

        // Shuffle quizItems and select first nQuestions (or as many as available)
        shuffleArray(quizItems);
        if (quizItems.length > nQuestions) quizItems = quizItems.slice(0, nQuestions);

        // Save settings for use during quiz
        quizMeta = { N, M };

        currentQuizIndex = 0;
        listContainer.style.display = 'none';
        feedbackContainer.style.display = 'none';
        quizContainer.style.display = 'block';
        displayQuizQuestion();
    }

    // Show a quiz question
    function displayQuizQuestion() {
        if (currentQuizIndex >= quizItems.length) {
            alert('テスト終了です！お疲れ様でした。');
            listContainer.style.display = 'block';
            quizContainer.style.display = 'none';
            renderWordList();
            saveStats();
            return;
        }

        const currentQuizItem = quizItems[currentQuizIndex];
        const correctAnswerDef = currentQuizItem.definition;

        quizProgressEl.textContent = `4択テスト (${currentQuizIndex + 1} / ${quizItems.length})`;
        quizWordEl.textContent = currentQuizItem.word;

        // Build options: correct + 3 distractors (different meanings)
        let options = [correctAnswerDef];
        const triesMax = 1000;
        let tries = 0;
        while (options.length < 4 && tries < triesMax) {
            tries++;
            const randomWord = allWords[Math.floor(Math.random() * allWords.length)];
            const defs = randomWord.definitions || [];
            if (defs.length === 0) continue;
            const randomDef = defs[Math.floor(Math.random() * defs.length)];
            if (!randomDef || !(randomDef.meaning||'').trim()) continue;
            if (!options.some(opt => (opt.meaning||'').trim().toLowerCase() === (randomDef.meaning||'').trim().toLowerCase())) {
                options.push(randomDef);
            }
        }
        // If still not enough (rare), duplicate with placeholder to fill
        while (options.length < 4) options.push({pos:'', meaning: '(選択肢不足)', example:''});

        shuffleArray(options);

        quizOptionsEl.innerHTML = '';
        options.forEach(opt => {
            const button = document.createElement('button');
            button.className = 'option-btn';
            button.innerHTML = `<div class="meaning">${escapeHtml(opt.meaning)}</div><div class="small">${escapeHtml(opt.pos)}</div>`;
            button.onclick = () => handleAnswer((opt.meaning||'').trim() === (correctAnswerDef.meaning||'').trim(), currentQuizItem);
            quizOptionsEl.appendChild(button);
        });
    }

    // Handle answer (auto-advance on correct)
    let quizMeta = { N: 3, M: 7 };
    function handleAnswer(isCorrect, quizItem) {
        const wordId = String(quizItem.id);
        if (isCorrect) {
            // update stats: increment consecutive correct for the word and possibly hide it
            if (!wordStats[wordId]) wordStats[wordId] = {consecutiveCorrect: 0, hiddenUntil: null};
            wordStats[wordId].consecutiveCorrect = (wordStats[wordId].consecutiveCorrect || 0) + 1;
            // If reaches N, set hiddenUntil = now + M days, and reset counter
            if (wordStats[wordId].consecutiveCorrect >= (quizMeta.N || 1)) {
                if (quizMeta.M && quizMeta.M > 0) {
                    const days = quizMeta.M;
                    const until = Date.now() + days * 24 * 60 * 60 * 1000;
                    wordStats[wordId].hiddenUntil = until;
                }
                wordStats[wordId].consecutiveCorrect = 0;
            }
            saveStats();
            // auto-advance
            currentQuizIndex++;
            displayQuizQuestion();
        } else {
            // incorrect: mark original word checked, reset consecutive count
            const originalWord = allWords.find(w => String(w.id) === wordId);
            if (originalWord) {
                originalWord.checked = true;
                lastIncorrectWordId = String(originalWord.id);
                if (!wordStats[wordId]) wordStats[wordId] = {consecutiveCorrect: 0, hiddenUntil: null};
                wordStats[wordId].consecutiveCorrect = 0;
                saveStats();

                feedbackTitle.textContent = '不正解... チェックリストに追加しました';
                // show all definitions, highlight the incorrect one
                let definitionsHtml = '';
                originalWord.definitions.forEach(def => {
                    const isIncorrectDef = (def.meaning || '').trim() === (quizItem.definition.meaning || '').trim();
                    definitionsHtml += `
                        <div class="definition-item" style="${isIncorrectDef ? 'font-weight:bold; color:var(--red);' : ''}">
                            <div>
                                <span class="pos">${escapeHtml(def.pos)}</span>
                                <span class="meaning">${escapeHtml(def.meaning)}</span>
                            </div>
                            <div class="example">例: ${escapeHtml(def.example)}</div>
                        </div>
                    `;
                });

                feedbackDetailsEl.innerHTML = `
                    <div><span class="word">${escapeHtml(originalWord.word)}</span></div>
                    ${definitionsHtml}
                `;
                feedbackContainer.style.display = 'block';
                // note: do not auto-advance on incorrect; user can undo check then continue
            } else {
                // fallback: just advance
                currentQuizIndex++;
                displayQuizQuestion();
            }
            // reflect checked state in UI
            renderWordList();
        }
    }

    function undoLastCheck() {
        if (lastIncorrectWordId !== null) {
            const word = allWords.find(w => String(w.id) === String(lastIncorrectWordId));
            if (word) {
                word.checked = false;
                lastIncorrectWordId = null;
                feedbackContainer.style.display = 'none';
                persistWordsToLocal();
                renderWordList();
                alert(`「${word.word}」のチェックを取り消しました。`);
            }
        }
    }

    // Utility: Fisher-Yates shuffle
    function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }

    // Load previously persisted stats and optionally persisted local word meta
    (function initialLoad() {
        // Try to load local persisted config if any (but not auto-fetching files)
        const rawLocal = localStorage.getItem('englishWords_local_v1');
        if (rawLocal) {
            try {
                const obj = JSON.parse(rawLocal);
                if (obj.filesState) filesState = obj.filesState;
            } catch (e) { /* ignore */ }
        }
        // No automatic fetch here other than initial load below.
    })();

    // Start by auto-loading filenames in input (if possible)
    loadWords({mode: 'append'});
});
</script>
</body>
</html>
