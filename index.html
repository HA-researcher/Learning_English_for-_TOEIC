<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‹±å˜èªå­¦ç¿’ã‚¢ãƒ—ãƒª (è¤‡æ•°æ„å‘³å¯¾å¿œç‰ˆ) â€” æ”¹è‰¯v1.2</title>
    <style>
        :root { --main-color: #007bff; --light-gray: #f8f9fa; --gray: #6c757d; --red: #dc3545; --green: #28a745; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; background-color: var(--light-gray); display: flex; justify-content: center; }
        .container { width: 100%; max-width: 1000px; background-color: #fff; margin: 20px; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1, h2 { color: #333; text-align: center; }
        .controls, .quiz-controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 20px; align-items: center; }
        .controls input[type="text"], .controls input[type="number"], .controls select { padding: 8px; border: 1px solid #ccc; border-radius: 4px; min-width: 120px; }
        button { padding: 10px 15px; border: none; border-radius: 4px; color: #fff; cursor: pointer; transition: background-color 0.2s; }
        .btn-primary { background-color: var(--main-color); }
        .btn-primary:hover { background-color: #0056b3; }
        .btn-secondary { background-color: var(--gray); }
        .btn-secondary:hover { background-color: #5a6268; }
        .btn-success { background-color: var(--green); }
        .btn-success:hover { background-color: #218838; }
        #word-list { list-style: none; padding: 0; max-height: 400px; overflow-y: auto; border-top: 1px solid #eee; margin-top: 10px; }
        .word-item { display: flex; align-items: flex-start; gap: 10px; padding: 10px; border-bottom: 1px solid #eee; }
        .word-item.hidden { opacity: 0.4; }
        .word-item.checked { background-color: #e9f5ff; }
        .word-item input[type="checkbox"] { margin-top: 5px; width: 18px; height: 18px; flex-shrink: 0; }
        .word-details { flex-grow: 1; }
        .word-details .word { font-size: 1.2em; font-weight: bold; }
        .definition-item { margin-top: 8px; margin-left: 10px; }
        .definition-item .pos { font-style: italic; color: var(--gray); margin-right: 8px; }
        .definition-item .meaning { font-weight: 500; }
        .definition-item .example { color: #555; margin-top: 4px; font-size: 0.9em; }
        #quiz-container, #feedback-container { display: none; padding: 20px; margin-top: 20px; border: 1px solid #ddd; border-radius: 8px; }
        #quiz-word { font-size: 2em; font-weight: bold; text-align: center; margin-bottom: 20px; }
        #quiz-options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .option-btn { width: 100%; padding: 15px; background-color: #f1f1f1; color: #333; text-align: left; font-size: 1em; border-radius: 6px; border: 1px solid transparent; cursor: pointer; }
        .option-btn:hover { background-color: #e0e0e0; }
        #feedback-container { background-color: #fffbe6; border-color: #ffe58f; }
        #feedback-container.correct { background-color: #e9f7ef; border-color: #a6d9b8; }
        .feedback-actions { margin-top: 15px; }
        .file-list { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
        .file-item { background:#f7f7f7; padding:6px 8px; border-radius:6px; border:1px solid #eee; display:flex; gap:6px; align-items:center; }
        .small { font-size:0.85em; color:var(--gray); }
        .meta { display:flex; gap:10px; align-items:center; }
        .hidden-note { color: var(--red); font-weight: 600; margin-left: 8px; font-size: 0.95em; }
        .unhide-btn { background: #ffb84d; color: #000; padding: 4px 8px; border-radius: 6px; border:none; cursor:pointer; }
        .remove-btn { background: #dc3545; padding: 4px 8px; color: #fff; border-radius: 6px; border: none; cursor: pointer; }
        .note { color: var(--gray); font-size: 0.9em; margin-left: 6px; }
        #local-file-input { display:inline-block; }
    </style>
</head>
<body>
    <div class="container">
        <h1>è‹±å˜èªå­¦ç¿’ã‚¢ãƒ—ãƒª (è¤‡æ•°æ„å‘³å¯¾å¿œç‰ˆ) â€” æ”¹è‰¯ç‰ˆ</h1>
        
        <div class="controls">
            <input type="text" id="json-files-input" value="Words_01.json" placeholder="ä¾‹: Words_01.json, SWEwords_1.json">
            <button id="load-btn" class="btn-primary">ğŸ”„ èª­è¾¼ï¼ˆè¿½åŠ  / URLï¼‰</button>

            <label class="small note">ã¾ãŸã¯ãƒ­ãƒ¼ã‚«ãƒ«JSONã‚’é¸æŠï¼š</label>
            <input type="file" id="local-file-input" accept=".json,application/json" multiple>
            <button id="load-local-btn" class="btn-primary">ğŸ“ ãƒ­ãƒ¼ã‚«ãƒ«èª­ã¿è¾¼ã¿</button>

            <div class="file-list" id="loaded-files" title="èª­ã¿è¾¼ã¾ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§"></div>

            <button id="export-btn" class="btn-secondary">ğŸ“„ ãƒã‚§ãƒƒã‚¯ã—ãŸå˜èªã‚’ä¿å­˜</button>

            <div class="meta">
                <label class="small">å‡ºé¡Œæ•°: <input type="number" id="quiz-count" min="1" value="20" style="width:80px"></label>
                <label class="small">å‡ºé¡Œå¯¾è±¡:
                    <select id="quiz-scope">
                        <option value="unchecked">ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆå¤– (æœªãƒã‚§ãƒƒã‚¯)</option>
                        <option value="checked">ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆå†…</option>
                        <option value="all">å…¨ã¦</option>
                    </select>
                </label>
                <label class="small">N(é€£ç¶šæ­£è§£): <input type="number" id="consecutive-n" min="1" value="3" style="width:70px"></label>
                <label class="small">M(æ—¥é–“éè¡¨ç¤º): <input type="number" id="hide-days-m" min="0" value="7" style="width:70px"></label>
                <label class="small"><input type="checkbox" id="show-hidden"> éè¡¨ç¤ºä¸­ã‚’è¡¨ç¤º</label>
            </div>

            <button id="start-quiz-btn" class="btn-success">ğŸ§  4æŠãƒ†ã‚¹ãƒˆé–‹å§‹</button>
        </div>

        <div id="list-container">
            <h2>å˜èªãƒªã‚¹ãƒˆ (<span id="word-count">0</span>)</h2>
            <ul id="word-list"></ul>
        </div>

        <div id="quiz-container">
            <h2 id="quiz-progress">4æŠãƒ†ã‚¹ãƒˆ</h2>
            <div id="quiz-word"></div>
            <div id="quiz-options"></div>
        </div>

        <div id="feedback-container">
            <h2 id="feedback-title">ä¸æ­£è§£... ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã«è¿½åŠ ã—ã¾ã—ãŸ</h2>
            <div class="word-details" id="feedback-details"></div>
            <div class="feedback-actions">
                <button id="undo-check-btn" class="btn-secondary">ã‚„ã£ã±ã‚Šå–ã‚Šæ¶ˆã™</button>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // DOM
    const jsonFilesInput = document.getElementById('json-files-input');
    const loadBtn = document.getElementById('load-btn');
    const loadLocalBtn = document.getElementById('load-local-btn');
    const localFileInput = document.getElementById('local-file-input');
    const exportBtn = document.getElementById('export-btn');
    const startQuizBtn = document.getElementById('start-quiz-btn');
    const wordListEl = document.getElementById('word-list');
    const wordCountEl = document.getElementById('word-count');
    const quizContainer = document.getElementById('quiz-container');
    const listContainer = document.getElementById('list-container');
    const quizProgressEl = document.getElementById('quiz-progress');
    const quizWordEl = document.getElementById('quiz-word');
    const quizOptionsEl = document.getElementById('quiz-options');
    const feedbackContainer = document.getElementById('feedback-container');
    const feedbackTitle = document.getElementById('feedback-title');
    const feedbackDetailsEl = document.getElementById('feedback-details');
    const undoCheckBtn = document.getElementById('undo-check-btn');
    const loadedFilesEl = document.getElementById('loaded-files');
    const quizCountInput = document.getElementById('quiz-count');
    const quizScopeSelect = document.getElementById('quiz-scope');
    const consecutiveNInput = document.getElementById('consecutive-n');
    const hideDaysMInput = document.getElementById('hide-days-m');
    const showHiddenCheckbox = document.getElementById('show-hidden');

    // State
    let allWords = []; // {id (string), word, checked, definitions: [...], _files: [...]} merged across files
    let filesState = []; // [{name, included:true, source: 'remote'|'local'}]
    let quizItems = []; // [{id, word, definition}]
    let currentQuizIndex = 0;
    let lastIncorrectWordId = null;

    // Persisted stats per word
    const STATS_KEY = 'englishWords_stats_v1';
    let wordStats = loadStats(); // { [id]: {consecutiveCorrect: number, hiddenUntil: timestamp|null} }

    // Events
    loadBtn.addEventListener('click', () => loadRemoteFiles());
    loadLocalBtn.addEventListener('click', () => {
        const files = Array.from(localFileInput.files || []);
        if (files.length === 0) return alert('ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
        loadLocalFiles(files);
    });
    exportBtn.addEventListener('click', exportCheckedWords);
    startQuizBtn.addEventListener('click', startQuiz);
    undoCheckBtn.addEventListener('click', undoLastCheck);
    showHiddenCheckbox.addEventListener('change', renderWordList);

    wordListEl.addEventListener('change', (e) => {
        if (e.target.type === 'checkbox' && e.target.dataset.id) {
            const wordId = String(e.target.dataset.id);
            const word = allWords.find(w => String(w.id) === wordId);
            if (word) {
                word.checked = e.target.checked;
                e.target.closest('.word-item').classList.toggle('checked', word.checked);
                persistWordsToLocal(); // optional persist of current checked state
            }
        }
    });

    // --- Functions ---

    function loadStats() {
        try {
            const raw = localStorage.getItem(STATS_KEY);
            return raw ? JSON.parse(raw) : {};
        } catch (e) {
            console.error('loadStats error', e);
            return {};
        }
    }
    function saveStats() {
        try {
            localStorage.setItem(STATS_KEY, JSON.stringify(wordStats));
        } catch (e) {
            console.error('saveStats error', e);
        }
    }
    function persistWordsToLocal() {
        // Keep checked state and basic meta in localStorage so UX is smoother across reloads
        try {
            const payload = {
                filesState,
                allWordsBasic: allWords.map(w => ({id: String(w.id), checked: !!w.checked, _files: w._files || []}))
            };
            localStorage.setItem('englishWords_local_v1', JSON.stringify(payload));
        } catch (e) { console.warn(e); }
    }
    function loadPersistedWords() {
        try {
            const raw = localStorage.getItem('englishWords_local_v1');
            if (!raw) return;
            const obj = JSON.parse(raw);
            if (obj.filesState) filesState = obj.filesState;
            if (obj.allWordsBasic) {
                obj.allWordsBasic.forEach(b => {
                    const w = allWords.find(x => String(x.id) === String(b.id));
                    if (w) {
                        w.checked = b.checked;
                        w._files = b._files || w._files || [];
                    }
                });
            }
        } catch (e) { console.warn('loadPersistedWords', e); }
    }

    // Normalize various json formats into definitions array of {pos, meaning, example}
    function normalizeDefinitions(wordObj) {
        const out = [];
        // Helper to push unique meaning
        function pushDef(pos, meaning, example) {
            meaning = (meaning === undefined || meaning === null) ? '' : String(meaning).trim();
            pos = pos || '';
            example = example || '';
            if (!out.some(d => (d.meaning || '').trim().toLowerCase() === meaning.toLowerCase())) {
                out.push({pos, meaning, example});
            }
        }

        // 1) word.definitions as array
        if (Array.isArray(wordObj.definitions)) {
            wordObj.definitions.forEach(d => {
                if (typeof d === 'string') {
                    pushDef('', d, '');
                } else if (d && typeof d === 'object') {
                    let meaning = d.meaning || d.meanings || d.def || d.text || d.gloss || '';
                    if (Array.isArray(d.meanings)) meaning = d.meanings.join('; ');
                    pushDef(d.pos || d.partOfSpeech || d.posTag || '', meaning, d.example || (Array.isArray(d.examples) ? d.examples.join(' / ') : d.examples) || '');
                }
            });
        }

        // 2) word.meanings or word.meaning (string or array)
        if (out.length === 0) {
            if (wordObj.meanings) {
                if (Array.isArray(wordObj.meanings)) {
                    wordObj.meanings.forEach(m => {
                        if (typeof m === 'string') pushDef('', m, '');
                        else if (m && typeof m === 'object') pushDef(m.pos || '', m.meaning || m.text || '', m.example || '');
                    });
                } else {
                    pushDef('', wordObj.meanings, '');
                }
            } else if (wordObj.meaning) {
                if (typeof wordObj.meaning === 'string') pushDef('', wordObj.meaning, '');
                else if (Array.isArray(wordObj.meaning)) wordObj.meaning.forEach(m => pushDef('', m, ''));
            }
        }

        // 3) word.definition (singular)
        if (out.length === 0 && wordObj.definition) {
            if (typeof wordObj.definition === 'string') pushDef('', wordObj.definition, '');
            else if (Array.isArray(wordObj.definition)) wordObj.definition.forEach(d => pushDef('', d, ''));
            else if (wordObj.definition && typeof wordObj.definition === 'object') {
                pushDef(wordObj.definition.pos || '', wordObj.definition.meaning || wordObj.definition.text || '', wordObj.definition.example || '');
            }
        }

        // 4) other known keys / fallback
        if (out.length === 0) {
            if (wordObj.gloss) pushDef('', wordObj.gloss, '');
            else if (wordObj.shortdef) {
                if (Array.isArray(wordObj.shortdef)) wordObj.shortdef.forEach(s => pushDef('', s, ''));
                else pushDef('', wordObj.shortdef, '');
            } else if (wordObj.translation) {
                if (Array.isArray(wordObj.translation)) wordObj.translation.forEach(t => pushDef('', t, ''));
                else pushDef('', wordObj.translation, '');
            }
        }

        return out;
    }

    // Merge helper: map existing allWords into a map keyed by string id
    function seedMapFromAllWords(map) {
        allWords.forEach(w => {
            map.set(String(w.id), {
                id: String(w.id),
                word: w.word || '',
                checked: !!w.checked,
                definitions: Array.isArray(w.definitions) ? w.definitions.slice() : [],
                _files: Array.isArray(w._files) ? w._files.slice() : []
            });
        });
    }

    // Load remote files (by URL or relative path). Adds new files; does not remove existing files unless user explicitly removes them.
    async function loadRemoteFiles() {
        const filenames = jsonFilesInput.value.split(',').map(f => f.trim()).filter(f => f);
        if (filenames.length === 0) return alert('ãƒ•ã‚¡ã‚¤ãƒ«å/URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');

        // Determine toFetch (files not already known)
        const existingNames = new Set(filesState.map(f => f.name));
        const toFetch = filenames.filter(f => !existingNames.has(f));
        // If a file name is already known but the user typed it, ensure it's marked included
        filenames.forEach(name => {
            const idx = filesState.findIndex(x => x.name === name);
            if (idx >= 0) filesState[idx].included = true;
        });

        // Fetch new ones
        const fetchResults = await Promise.allSettled(toFetch.map(f => fetch(f)));

        // Build merge map
        const map = new Map();
        seedMapFromAllWords(map);

        for (let i = 0; i < fetchResults.length; i++) {
            const fname = toFetch[i];
            const res = fetchResults[i];
            if (res.status === 'fulfilled') {
                const response = res.value;
                if (!response.ok) {
                    console.warn(`${fname} ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${response.status}`);
                    continue;
                }
                let arr;
                try {
                    arr = await response.json();
                } catch (e) {
                    console.warn(`${fname} ã®JSONè§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚`, e);
                    continue;
                }
                if (!Array.isArray(arr)) {
                    console.warn(`${fname} ã®å†…å®¹ãŒé…åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚`);
                    continue;
                }

                arr.forEach(word => {
                    if (!word) return;
                    const idKey = (typeof word.id !== 'undefined' && word.id !== null) ? String(word.id) : (`__noid__${fname}__${String(word.word||'')}`);
                    const existing = map.get(idKey);
                    const defs = normalizeDefinitions(word);

                    if (existing) {
                        defs.forEach(d => {
                            if (!existing.definitions.some(ed => (ed.meaning||'').trim().toLowerCase() === (d.meaning||'').trim().toLowerCase())) {
                                existing.definitions.push(d);
                            }
                        });
                        if (!existing._files.includes(fname)) existing._files.push(fname);
                        existing.checked = existing.checked || !!word.checked;
                        if (!existing.word && word.word) existing.word = word.word;
                    } else {
                        map.set(idKey, {
                            id: idKey,
                            word: word.word || '',
                            checked: !!word.checked,
                            definitions: defs,
                            _files: [fname]
                        });
                    }
                });
            } else {
                console.warn(`ãƒ•ã‚¡ã‚¤ãƒ« ${toFetch[i]} ã®ãƒ•ã‚§ãƒƒãƒã§ã‚¨ãƒ©ãƒ¼:`, res.reason);
            }
        }

        // Update filesState: add fetched files (or files user typed) as included
        const prevMap = new Map(filesState.map(f => [f.name, f.included]));
        // ensure all filenames are known and included
        filenames.forEach(name => prevMap.set(name, true));
        // also add files discovered inside map (from _files)
        map.forEach(w => (w._files || []).forEach(fn => prevMap.set(fn, prevMap.get(fn) === undefined ? true : prevMap.get(fn))));

        // rebuild filesState preserving user-specified order first
        const newFilesState = [];
        const added = new Set();
        filenames.forEach(name => {
            newFilesState.push({name, included: !!prevMap.get(name), source: toFetch.includes(name) ? 'remote' : 'remote'});
            added.add(name);
        });
        filesState.forEach(f => {
            if (!added.has(f.name)) {
                newFilesState.push({name: f.name, included: !!prevMap.get(f.name), source: f.source || 'remote'});
                added.add(f.name);
            }
        });
        // add any other discovered files
        map.forEach(w => (w._files || []).forEach(fn => {
            if (!added.has(fn)) {
                newFilesState.push({name: fn, included: true, source: 'remote'});
                added.add(fn);
            }
        }));

        filesState = newFilesState;
        allWords = Array.from(map.values());
        loadPersistedWords();
        renderFilesList();
        renderWordList();
        persistWordsToLocal();

        alert(`${allWords.length}èªã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼ˆæ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«: ${toFetch.length} ä»¶ï¼‰ã€‚`);
    }

    // Load local File objects (from input). These are given a name and 'local' source.
    async function loadLocalFiles(files) {
        const map = new Map();
        seedMapFromAllWords(map);

        for (const file of files) {
            let txt;
            try {
                txt = await file.text();
            } catch (e) {
                console.warn(`${file.name} ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`, e);
                continue;
            }
            let arr;
            try {
                arr = JSON.parse(txt);
            } catch (e) {
                console.warn(`${file.name} ã®JSONè§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚`, e);
                continue;
            }
            if (!Array.isArray(arr)) {
                console.warn(`${file.name} ã®å†…å®¹ãŒé…åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚`);
                continue;
            }
            arr.forEach(word => {
                if (!word) return;
                const fname = file.name;
                const idKey = (typeof word.id !== 'undefined' && word.id !== null) ? String(word.id) : (`__noid__${fname}__${String(word.word||'')}`);
                const existing = map.get(idKey);
                const defs = normalizeDefinitions(word);

                if (existing) {
                    defs.forEach(d => {
                        if (!existing.definitions.some(ed => (ed.meaning||'').trim().toLowerCase() === (d.meaning||'').trim().toLowerCase())) {
                            existing.definitions.push(d);
                        }
                    });
                    if (!existing._files.includes(fname)) existing._files.push(fname);
                    existing.checked = existing.checked || !!word.checked;
                    if (!existing.word && word.word) existing.word = word.word;
                } else {
                    map.set(idKey, {
                        id: idKey,
                        word: word.word || '',
                        checked: !!word.checked,
                        definitions: defs,
                        _files: [fname]
                    });
                }
            });
        }

        // Update filesState: add local files (marked as included by default)
        const prevMap = new Map(filesState.map(f => [f.name, f.included]));
        Array.from(files).forEach(file => prevMap.set(file.name, true));
        // rebuild filesState: keep previous order, then add new local files if needed
        const newFilesState = [];
        const added = new Set();
        // First add previously-known files (preserve order)
        filesState.forEach(f => {
            newFilesState.push({name: f.name, included: !!prevMap.get(f.name), source: f.source || 'remote'});
            added.add(f.name);
        });
        // Then add new local files
        Array.from(files).forEach(file => {
            if (!added.has(file.name)) {
                newFilesState.push({name: file.name, included: true, source: 'local'});
                added.add(file.name);
            }
        });
        // Also add any discovered file names from data
        map.forEach(w => (w._files || []).forEach(fn => {
            if (!added.has(fn)) {
                newFilesState.push({name: fn, included: true, source: 'local'});
                added.add(fn);
            }
        }));

        filesState = newFilesState;
        allWords = Array.from(map.values());
        loadPersistedWords();
        renderFilesList();
        renderWordList();
        persistWordsToLocal();

        alert(`ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ« ${files.length} ä»¶ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚`);
    }

    function renderFilesList() {
        loadedFilesEl.innerHTML = '';
        filesState.forEach((f, idx) => {
            const div = document.createElement('div');
            div.className = 'file-item';
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.checked = !!f.included;
            cb.title = 'ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¡¨ç¤ºã®å¯¾è±¡ã«å«ã‚ã‚‹ / é™¤å¤–ã™ã‚‹';
            cb.addEventListener('change', () => {
                filesState[idx].included = cb.checked;
                renderWordList();
                persistWordsToLocal();
            });
            const label = document.createElement('span');
            label.textContent = `${f.name} ${f.source ? '(' + f.source + ')' : ''}`;
            label.style.maxWidth = '260px';
            label.style.overflow = 'hidden';
            label.style.textOverflow = 'ellipsis';
            label.style.whiteSpace = 'nowrap';
            const excludeBtn = document.createElement('button');
            excludeBtn.className = 'unhide-btn';
            excludeBtn.textContent = f.included ? 'é™¤å¤–' : 'å«ã‚ã‚‹';
            excludeBtn.onclick = () => {
                filesState[idx].included = !filesState[idx].included;
                cb.checked = filesState[idx].included;
                excludeBtn.textContent = filesState[idx].included ? 'é™¤å¤–' : 'å«ã‚ã‚‹';
                renderWordList();
                persistWordsToLocal();
            };
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.textContent = 'å‰Šé™¤';
            removeBtn.title = 'èª­ã¿è¾¼ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å®Œå…¨ã«å–ã‚Šé™¤ãã¾ã™ï¼ˆãã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ãŒæŒã¤å˜èªã¯æ¶ˆãˆã¾ã™ï¼‰';
            removeBtn.onclick = () => {
                if (!confirm(`${f.name} ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ç”±æ¥ã®å˜èªã§ä»–ã«å‚ç…§ãŒãªã„ã‚‚ã®ã¯ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤ã•ã‚Œã¾ã™ã€‚`)) return;
                removeFileAndItsWords(f.name);
            };

            div.appendChild(cb);
            div.appendChild(label);
            div.appendChild(excludeBtn);
            div.appendChild(removeBtn);
            loadedFilesEl.appendChild(div);
        });
    }

    function removeFileAndItsWords(fname) {
        // Remove file from filesState
        filesState = filesState.filter(f => f.name !== fname);
        // Remove file from _files arrays and remove words that have no files left
        allWords = allWords.filter(w => {
            w._files = (w._files || []).filter(fn => fn !== fname);
            return (w._files && w._files.length > 0) || (w._files && w._files.length === 0 && w._manual); // keep manual words if any
        });
        // Persist and rerender
        persistWordsToLocal();
        renderFilesList();
        renderWordList();
    }

    function isFileIncluded(fname) {
        const f = filesState.find(x => x.name === fname);
        return f ? !!f.included : true;
    }

    // Render words: respects file include/exclude and per-word hiddenUntil, and showHidden checkbox
    function renderWordList() {
        wordListEl.innerHTML = '';
        const showHidden = showHiddenCheckbox.checked;
        // sort alphabetically
        allWords.sort((a, b) => (a.word || '').localeCompare(b.word || ''));
        const now = Date.now();

        const visibleWords = allWords.filter(w => {
            const files = w._files || [];
            const included = files.length === 0 ? true : files.some(isFileIncluded);
            if (!included) return false;
            const stats = wordStats[String(w.id)];
            const hiddenUntil = stats && stats.hiddenUntil ? stats.hiddenUntil : null;
            if (hiddenUntil && hiddenUntil > now) {
                return showHidden; // show only if showHidden true
            }
            return true;
        });

        visibleWords.forEach(word => {
            const stats = wordStats[String(word.id)] || {consecutiveCorrect: 0, hiddenUntil: null};
            const isHidden = stats.hiddenUntil && stats.hiddenUntil > Date.now();
            const li = document.createElement('li');
            li.className = 'word-item' + (word.checked ? ' checked' : '') + (isHidden ? ' hidden' : '');
            let definitionsHtml = '';
            (word.definitions || []).forEach(def => {
                definitionsHtml += `
                    <div class="definition-item">
                        <div>
                            <span class="pos">${escapeHtml(def.pos)}</span>
                            <span class="meaning">${escapeHtml(def.meaning)}</span>
                        </div>
                        <div class="example">ä¾‹: ${escapeHtml(def.example)}</div>
                    </div>
                `;
            });

            // Unhide button (visible only when hidden)
            const unhideButtonHtml = isHidden ? `<button class="unhide-btn" data-id="${escapeHtml(String(word.id))}">éè¡¨ç¤ºè§£é™¤</button>` : '';

            li.innerHTML = `
                <input type="checkbox" data-id="${escapeHtml(String(word.id))}" ${word.checked ? 'checked' : ''}>
                <div class="word-details">
                    <div><span class="word">${escapeHtml(word.word)}</span> ${isHidden ? '<span class="hidden-note">ï¼ˆéè¡¨ç¤ºä¸­ï¼‰</span>' : ''}</div>
                    <div class="small">ãƒ•ã‚¡ã‚¤ãƒ«: ${escapeHtml((word._files||[]).join(', '))} / é€£ç¶šæ­£è§£: ${stats.consecutiveCorrect || 0}</div>
                    ${definitionsHtml}
                </div>
                <div>
                    ${unhideButtonHtml}
                </div>
            `;
            wordListEl.appendChild(li);

            if (isHidden) {
                const btn = li.querySelector('button.unhide-btn');
                if (btn) {
                    btn.addEventListener('click', () => {
                        if (!wordStats[String(word.id)]) wordStats[String(word.id)] = {consecutiveCorrect: 0, hiddenUntil: null};
                        wordStats[String(word.id)].hiddenUntil = null;
                        wordStats[String(word.id)].consecutiveCorrect = 0;
                        saveStats();
                        renderWordList();
                    });
                }
            }
        });

        wordCountEl.textContent = visibleWords.length;
    }

    function escapeHtml(str) {
        if (str === undefined || str === null) return '';
        return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[s]);
    }

    // Export checked words (only those from included files)
    function exportCheckedWords() {
        const checkedWords = allWords.filter(w => w.checked && (w._files || []).some(isFileIncluded));
        if (checkedWords.length === 0) return alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹å˜èªãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
        const jsonString = JSON.stringify(checkedWords, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        a.download = `CheckWords_${timestamp}.json`;
        a.href = url;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // Start quiz
    function startQuiz() {
        const scope = quizScopeSelect.value; // 'unchecked' | 'checked' | 'all'
        const nQuestions = Math.max(1, parseInt(quizCountInput.value) || 1);
        const N = Math.max(1, parseInt(consecutiveNInput.value) || 1);
        const M = Math.max(0, parseInt(hideDaysMInput.value) || 0);
        const now = Date.now();

        const poolWords = allWords.filter(w => {
            const files = w._files || [];
            const included = files.length === 0 ? true : files.some(isFileIncluded);
            if (!included) return false;
            const stats = wordStats[String(w.id)] || {};
            if (stats.hiddenUntil && stats.hiddenUntil > now) return false; // skip hidden
            if (scope === 'checked') return !!w.checked;
            if (scope === 'unchecked') return !w.checked;
            return true;
        });

        // Build quiz items as definition-level items
        quizItems = [];
        poolWords.forEach(word => {
            (word.definitions || []).forEach(def => {
                if (def && (def.meaning || '').trim() !== '') {
                    quizItems.push({ id: word.id, word: word.word, definition: def });
                }
            });
        });

        if (quizItems.length < 4) {
            return alert('ãƒ†ã‚¹ãƒˆã‚’è¡Œã†ã«ã¯ã€å¯¾è±¡ã¨ãªã‚‹å˜èªï¼ˆæ„å‘³ãƒšã‚¢ï¼‰ãŒ4ã¤ä»¥ä¸Šå¿…è¦ã§ã™ã€‚ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚„éè¡¨ç¤ºè¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        }

        shuffleArray(quizItems);
        if (quizItems.length > nQuestions) quizItems = quizItems.slice(0, nQuestions);
        quizMeta = { N, M };

        currentQuizIndex = 0;
        listContainer.style.display = 'none';
        feedbackContainer.style.display = 'none';
        quizContainer.style.display = 'block';
        displayQuizQuestion();
    }

    function displayQuizQuestion() {
        if (currentQuizIndex >= quizItems.length) {
            alert('ãƒ†ã‚¹ãƒˆçµ‚äº†ã§ã™ï¼ãŠç–²ã‚Œæ§˜ã§ã—ãŸã€‚');
            listContainer.style.display = 'block';
            quizContainer.style.display = 'none';
            renderWordList();
            saveStats();
            return;
        }

        const currentQuizItem = quizItems[currentQuizIndex];
        const correctAnswerDef = currentQuizItem.definition;

        quizProgressEl.textContent = `4æŠãƒ†ã‚¹ãƒˆ (${currentQuizIndex + 1} / ${quizItems.length})`;
        quizWordEl.textContent = currentQuizItem.word;

        // Build options: correct + 3 distractors (different meanings)
        let options = [correctAnswerDef];
        const triesMax = 1000;
        let tries = 0;
        while (options.length < 4 && tries < triesMax) {
            tries++;
            const randomWord = allWords[Math.floor(Math.random() * allWords.length)];
            const defs = randomWord.definitions || [];
            if (defs.length === 0) continue;
            const randomDef = defs[Math.floor(Math.random() * defs.length)];
            if (!randomDef || !(randomDef.meaning||'').trim()) continue;
            if (!options.some(opt => (opt.meaning||'').trim().toLowerCase() === (randomDef.meaning||'').trim().toLowerCase())) {
                options.push(randomDef);
            }
        }
        while (options.length < 4) options.push({pos:'', meaning: '(é¸æŠè‚¢ä¸è¶³)', example:''});

        shuffleArray(options);

        quizOptionsEl.innerHTML = '';
        options.forEach(opt => {
            const button = document.createElement('button');
            button.className = 'option-btn';
            button.innerHTML = `<div class="meaning">${escapeHtml(opt.meaning)}</div><div class="small">${escapeHtml(opt.pos)}</div>`;
            button.onclick = () => handleAnswer((opt.meaning||'').trim() === (correctAnswerDef.meaning||'').trim(), currentQuizItem);
            quizOptionsEl.appendChild(button);
        });
    }

    // Handle answer (auto-advance on correct)
    let quizMeta = { N: 3, M: 7 };
    function handleAnswer(isCorrect, quizItem) {
        const wordId = String(quizItem.id);
        if (isCorrect) {
            if (!wordStats[wordId]) wordStats[wordId] = {consecutiveCorrect: 0, hiddenUntil: null};
            wordStats[wordId].consecutiveCorrect = (wordStats[wordId].consecutiveCorrect || 0) + 1;
            if (wordStats[wordId].consecutiveCorrect >= (quizMeta.N || 1)) {
                if (quizMeta.M && quizMeta.M > 0) {
                    const days = quizMeta.M;
                    const until = Date.now() + days * 24 * 60 * 60 * 1000;
                    wordStats[wordId].hiddenUntil = until;
                }
                wordStats[wordId].consecutiveCorrect = 0;
            }
            saveStats();
            currentQuizIndex++;
            displayQuizQuestion();
        } else {
            const originalWord = allWords.find(w => String(w.id) === wordId);
            if (originalWord) {
                originalWord.checked = true;
                lastIncorrectWordId = String(originalWord.id);
                if (!wordStats[wordId]) wordStats[wordId] = {consecutiveCorrect: 0, hiddenUntil: null};
                wordStats[wordId].consecutiveCorrect = 0;
                saveStats();

                feedbackTitle.textContent = 'ä¸æ­£è§£... ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã«è¿½åŠ ã—ã¾ã—ãŸ';
                let definitionsHtml = '';
                originalWord.definitions.forEach(def => {
                    const isIncorrectDef = (def.meaning || '').trim() === (quizItem.definition.meaning || '').trim();
                    definitionsHtml += `
                        <div class="definition-item" style="${isIncorrectDef ? 'font-weight:bold; color:var(--red);' : ''}">
                            <div>
                                <span class="pos">${escapeHtml(def.pos)}</span>
                                <span class="meaning">${escapeHtml(def.meaning)}</span>
                            </div>
                            <div class="example">ä¾‹: ${escapeHtml(def.example)}</div>
                        </div>
                    `;
                });

                feedbackDetailsEl.innerHTML = `
                    <div><span class="word">${escapeHtml(originalWord.word)}</span></div>
                    ${definitionsHtml}
                `;
                feedbackContainer.style.display = 'block';
            } else {
                currentQuizIndex++;
                displayQuizQuestion();
            }
            renderWordList();
        }
    }

    function undoLastCheck() {
        if (lastIncorrectWordId !== null) {
            const word = allWords.find(w => String(w.id) === String(lastIncorrectWordId));
            if (word) {
                word.checked = false;
                lastIncorrectWordId = null;
                feedbackContainer.style.display = 'none';
                persistWordsToLocal();
                renderWordList();
                alert(`ã€Œ${word.word}ã€ã®ãƒã‚§ãƒƒã‚¯ã‚’å–ã‚Šæ¶ˆã—ã¾ã—ãŸã€‚`);
            }
        }
    }

    // Utility: Fisher-Yates shuffle
    function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }

    // Load previously persisted stats and optionally persisted local word meta
    (function initialLoad() {
        const rawLocal = localStorage.getItem('englishWords_local_v1');
        if (rawLocal) {
            try {
                const obj = JSON.parse(rawLocal);
                if (obj.filesState) filesState = obj.filesState;
            } catch (e) { /* ignore */ }
        }
    })();

    // Start by auto-loading filenames in input (if possible)
    // Note: This will attempt to fetch the filename(s) in the input. If your SWEwords_1.json is a local file on your PC,
    // the browser cannot fetch it by name; instead use the ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ (ãƒ­ãƒ¼ã‚«ãƒ«èª­ã¿è¾¼ã¿) to load it.
    loadRemoteFiles();
});
</script>
</body>
</html>
